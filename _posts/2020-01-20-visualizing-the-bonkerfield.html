---
layout: post
title: 'Visualizing the Bonkerfield'
date: '2020-01-20'
author: Will Stedden
tags: 
- philosophy
- art
---

<p>For the past few weeks, I've been trying to figure out how to visually describe a philosophical concept that I've come up with called a <strong>bonkerfield</strong>. The bonkerfield is an idea that I've been ruminating on for a while now, and it's something very important to me that I'm trying hard to be able to communicate well. </p>

<p>I've elaborated on this subject at length on my <a href="/reasons/">reasons</a> page, but in short, a bonkerfield is a map of everywhere that any information and the parts of the information resided throughout all of space and time.  The idea sounds convoluted in words, but it's something that I have a pretty decent image of in my mind.</p>

<p>Originally I was planning to create a conceptual piece without too much detail.  I made a weak attempt in this chalk drawing. Hopefully, You get the idea of connectedness between different spots as if the idea is kind of being put together towards the point in time and then disseminated on the other side.</p>


IMAGE OF CHALK DRAWING OF THE BONKERFIELD


<p>But as I thought about it more, I figured it would be possible to realize this idea in a more concrete way.  I could manually tag the formation and dissemination of some idea and visualize it in a somewhat factual way.</p>


<p>Obviously, following ideas around in space and time is still pretty nebulous so I know I'm doomed to faillure in some sense.  Still, I wanted to try using the tools of the modern data scientist to manifest this philosophical concept.</p>


<h4>Spatiotemporally Fixed Hierarchical Clustering in d3</h4>
<p>Like I normally do in this situation, I went and scanned the web for things that already look kind of similar to what I'm trying.  At it's core, I wanted swoopy, pretty lines that connected nodes.  I figured that <a href="https://en.wikipedia.org/wiki/Mike_Bostock">Mike Bostock</a> of d3 fame must've built something like this at some point, and I wasn't dissapointed.</p>

<img src="/assets/images/2020/hierarchical_edge_bundling.png" title="Hierarchical Edge BUndling Viz by Mike Bostock">


<p>He'd built this <a href="https://bl.ocks.org/mbostock/5672200">hierarchical clustering vizualitation</a> that is a little different than what I want, but still really reminds me of the general feel. The data he was vizualizing in this example was the interconnectivity of software packages in a codebase.  He's used this as a basis for <a href="https://observablehq.com/@d3/hierarchical-edge-bundling">several</a> <a href="https://bl.ocks.org/mbostock/4341134">different</a> <a href="https://bl.ocks.org/mbostock/5672200">visualizations</a>, and humorously, I had previously exploited some of his <a href="https://bost.ocks.org/mike/hive/">related work</a> to make another attempted <a href="hellowill.bonkerfield.org">vizualization</a> of all the people I had worked with in my life.</p>

<img src="/assets/images/2020/hellowill_viz.png" title="plot of people projects and skills from my digital resume">

<p>I have <a href="/2015/01/05/a-better-linkedin/">another post</a> that explains building that visual.  It had constrained all projects along one radial line, skills on another, and people on a third.  To vizualize the bonkerfield, I needed to do something similar except the positional constraint would be along the x-axis and it would vary based on the time.</p>

<p>The time of interest is the time that some discernible event related to the formation of an idea would take place.  For now, I decided that spatial position wouldn't be demarked explicitly along the other axis.  Instead, I would use the clustering of events to automatically set where they lay. This way there shouldn't be too many overlapping lines in the final result.</p>


<h4>Selecting a test idea</h4>

<p>I was originally going to make my first test example very complicated, so that it would be really visually interesting and reveal some pattern in the data. But after starting to code, I realized I was going to have a lot of trouble just getting my code to work at all.  I walked it way back to a very simple scenario:</p>

<p><em>Imagine an author is writing a paragraph about a childhood memory with her mother.  In the paragraph, she quotes the phrase "Call me Ishmael" from Moby Dick.  Both of those pieces of information are baked into the bonkerfield of that paragraph.  After she publishes that paragraph in her memoir, a few Melville academics cite her.  In addition, something she says in that paragraph blows up as a meme on the internet.</em></p>

<p>
  Maybe this scenario isn't that realistic, and definitely not the best candidate to demonstrate the value of this idea. Still, it's simple enough and contained enough that I could keep it in my head long enough to hand annotate the data structure I was going to use for it.
</p>

<h4 id="results">Results</h4>
<p>You can view below for the implementation details, but before that I wanted to show what the general results were. There were a number of style variations that I wanted to explore in this piece.  the framework I have allows me to vary width and opacity of lines and to change the degree of randomness in the endpoints.</p>

<img class="small_img" title="Tame Bonkerfield" src="/assets/images/2020/bonker_viz_1.png">
<img class="small_img" title="Medium Bonkerfield" src="/assets/images/2020/bonker_viz_2.png">
<img class="small_img" title="Wild Bonkerfield" src="/assets/images/2020/bonker_viz_3.png">


<p>You can see the live d3 graph on <a href="/bonkerfield/">this page</a>.  Ideally, I'd like to be able to embed the d3 graph straight into a web site, but the way I built it doesn't allow for that yet. I'll leave it as is for now, but hopefully soon I can put more work into it </p>

<p>After building the simple version, I really wanted to scale it up to a more complex and interesting example.  Unfortunately, I didn't quite have time to compile real data or come up with another complicated story or for this one.  Instead, I just generated a bunch of random ones with a complicated branching structure.  The result is pretty impressive.</p>


ONE MORE COOLER MORE DETAILED EXAMPLE


<p>Once I get a really good example where I can work through and compile the data, I'll update with a thorough explanation of its bonkerfield.</p>

<h4>Implementation</h4>
<p>The rest of this article can help walk you through adapting my code and data to build your own bonkerfields.</p>
<h5>Compiling the data</h5>
<p>
  I had to hand annotate a json document in the structure needed for d3 to render it using the d3 "bundle" layout. Even though my data isn't really any kind of hierarchy, I'm sort of hacking the format that the d3 hierarchical bundling wants. 
</p>

<p>The minimal format to make it work requires two things:</p>
<ul>
  <li>a <code>.</code> delimited naming structure to define the hierarchy</li>
  <li>an import structure to define where th lines should be drawn between.</li>
</ul>

<p>
  I want everything to be drawn for the lowest nodes back up to the "paragraph" node, so I only need imports from the leafs to the paragraph node. To create a hierarchy for the leafs, I just needed to come up with higher order groupings that link things so their lines get drawn together on the way back up to the "paragraph" node.  The following document shows a simple example that would take two leaves for <code>bible</code> and <code>melville</code> and link them back to the paragraph via <code>mobydick</code>
</p>

<pre>
[
  {"name":"paragraph.mobydick.bible","imports":["paragraph"]},
  {"name":"paragraph.mobydick.melville","imports":["paragraph"]},
  {"name":"paragraph.mobydick","imports":[]},
  {"name":"paragraph","imports":[]},
]
</pre>

<p>To generate the full vizualization I added a couple more routes for the information to flow up to the paragraph.  I also added an additional <code>time</code>, <code>size</code>, and <code>weight</code> params that would set the x-position, the thickness of the line, and the transparency of the stroke, respectively.</p>
<pre>
[
  {"name":"paragraph.gap.visit.mom","time":100,"size":20,"weight":0.1,"imports":["paragraph"]},
  {"name":"paragraph.gap.visit.memory","time":100,"size":10,"weight":0.01,"imports":["paragraph"]},
  {"name":"paragraph.gap.blog.quotes","time":70,"size":10,"weight":0.05,"imports":["paragraph"]},
  {"name":"paragraph.gap.blog.mobydick.bible","time":10,"size":10,"weight":0.01,"imports":["paragraph"]},
  {"name":"paragraph.gap.blog.mobydick.melville","time":10,"size":10,"weight":0.1,"imports":["paragraph"]},
  {"name":"paragraph.gap.blog.mobydick","time":70,"size":10,"weight":0.05,"imports":[]},
  {"name":"paragraph.gap.visit","time":200,"size":10,"weight":0.05,"imports":[]},
  {"name":"paragraph.gap.blog","time":200,"size":10,"weight":0.05,"imports":[]},
  {"name":"paragraph.gap","time":300,"size":10,"weight":0.05,"imports":[]},
  {"name":"paragraph","time":350,"size":10,"weight":0.05,"imports":[]},
  {"name":"","time":350,"size":10,"weight":0.05,"imports":[]}
]
</pre>

<p>I also made a <a href="/assets/data/bonkerfield_post.json">similar document</a> to render the other side of the bonkerfield visualization.</p>

<h5>Coding the d3 vizualition</h5>
<p>Starting from the <a href="https://bl.ocks.org/mbostock/5672200">example code</a> that I found on <a href="https://bl.ocks.org/mbostock">bl.ocks.org</a>, I started making tweaks to the code.  Most of them were fairly minor sizing issues and rotations of things.  The only thing that was really crucial was figuring out how to set the x-position using the "time" field from the document.  Without that, the layout would put everything on one vertical line, which doesn't quite work for me.</p>

<p>The only crucial modification was to the node location, which required adding two bits of code.  The first was to modify the function that does the data load, in oder to transfer the data from the file into the <code>node</code> object that d3 uses from rendering the nodes of the graph.</p>

<pre>
function find(name, data) {
      var node = map[name], i;
      if (!node) {
        node = map[name] = data || {name: name, children: []};
        if (name.length) {
          node.parent = find(name.substring(0, i = name.lastIndexOf(".")));
          node.parent.children.push(node);
          node.key = name.substring(i + 1);
>          if (data){
>            node.time = data.time;
>          }else{
>            node.time = null;
>          }
          
        }
>      } else {
>        if(!node.time){
>          if (data){
>            node.time = data.time
>          }
>        }
      }
      return node;
    }
</pre>

<p>With that added, it's just necessary too use the <code>time</code> attribute when rendering the node SVG and the link SVG.</p>

<pre>
  ...
  var line_post = d3.svg.line()
    ...
    .x(function(d) {return d.time;})
  ...
  svg_post.selectAll(".node")
    ...
    .attr("transform", function(d) {return "translate(" + d.time + "," + d.x + ")";})
  ...
</pre>

<p>For a little extra flair, I also wanted to make more widely dispersed data show up as a thicker line.  To do that, I just added duplicated paths with randomly jittered endpoints.  You can check the code if you want to see how I duplicated the paths, but for the random jitter I used a simple rough approximation of a normal distribution in x and y.</p>

<pre>
function myrandom(){
  /* approximate a normal distribution (sort of) */
  /* using straight uniform makes everything look square */
  var r = 0;
  for(var i = 3; i > 0; i --){
      r += Math.random();
  }
  return 1.25*(r/3 - 0.5)
}

var line_pre = d3.svg.line()
  ...
  .x(function(d) {return d.time+myrandom()*d.size;})
  .y(function(d) {return d.x+myrandom()*d.size; });
</pre>

<p>As always, I've put the code to render this in its own github repository that you can check out here. Ii did a bunch more fiddling around and tried things different ways so the results in the repo might not match exactly with what I'm showing on this blog.</p>
